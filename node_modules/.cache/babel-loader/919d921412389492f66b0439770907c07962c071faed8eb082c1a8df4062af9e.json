{"ast":null,"code":"var _Tag;\nconst NUM_ROWS = 4;\nconst NUM_COLS = 4;\nconst NUM_TILES = NUM_ROWS * NUM_COLS;\nconst EMPTY_INDEX = NUM_TILES - 1;\nconst SHUFFLE_MOVES_RANGE = [60, 80];\nconst MOVE_DIRECTIONS = ['up', 'down', 'left', 'right'];\nfunction rand(min, max) {\n  return min + Math.floor(Math.random() * (max - min + 1));\n}\nexport default class Tag {\n  static getInstance() {\n    if (!Tag.instance) Tag.instance = new Tag();\n    return Tag.instance;\n  }\n  static getNewBoard() {\n    console.log('get new board');\n    return Array(NUM_TILES).fill(0).map((a, i) => [Math.floor(i / NUM_ROWS), i % NUM_COLS]);\n  }\n  constructor() {\n    this.startNewGame();\n  }\n  shuffle() {\n    this.shuffling = true;\n    let shuffleMoves = rand(...SHUFFLE_MOVES_RANGE);\n    console.log('shuffle -- ' + shuffleMoves);\n    while (shuffleMoves-- > 0) this.moveInDirection(MOVE_DIRECTIONS[rand(0, 3)]);\n    this.shuffling = false;\n  }\n  startNewGame() {\n    this.moves = 0;\n    this.board = Tag.getNewBoard();\n    this.stack = [];\n    this.seconds = 0;\n    this.shuffle();\n    console.log(\"start new Game\");\n  }\n  canMoveTile(index) {\n    console.log('can move tile');\n    if (index < 0 || index >= NUM_TILES) return false;\n    const tilePos = this.board[index];\n    const emptyPos = this.board[EMPTY_INDEX];\n    if (tilePos[0] === emptyPos[0]) return Math.abs(tilePos[1] - emptyPos[1]) === 1;else if (tilePos[1] === emptyPos[1]) return Math.abs(tilePos[0] - emptyPos[0]) === 1;else return false;\n  }\n  moveTile(index) {\n    console.log('Move title');\n    if (!this.shuffling && this.isSolved()) return false;\n    if (!this.canMoveTile(index)) return false;\n    const emptyPosition = [...this.board[EMPTY_INDEX]];\n    const tilePosition = [...this.board[index]];\n    let boardAfterMove = [...this.board];\n    boardAfterMove[EMPTY_INDEX] = tilePosition;\n    boardAfterMove[index] = emptyPosition;\n    if (!this.shuffling) this.stack.push(this.board);\n    this.board = boardAfterMove;\n    if (!this.shuffling) this.moves += 1;\n    return true;\n  }\n  isSolved() {\n    for (let i = 0; i < NUM_TILES; i++) {\n      if (this.board[i][0] !== Tag.solvedBoard[i][0] || this.board[i][1] !== Tag.solvedBoard[i][1]) return false;\n    }\n    return true;\n  }\n  moveInDirection(dir) {\n    const epos = this.board[EMPTY_INDEX];\n    console.log(dir + ' -- Move direction');\n    const posToMove = dir === 'up' ? [epos[0] + 1, epos[1]] : dir === 'down' ? [epos[0] - 1, epos[1]] : dir === 'left' ? [epos[0], epos[1] + 1] : dir === 'right' ? [epos[0], epos[1] - 1] : epos;\n    let tileToMove = EMPTY_INDEX;\n    for (let i = 0; i < NUM_TILES; i++) {\n      if (this.board[i][0] === posToMove[0] && this.board[i][1] === posToMove[1]) {\n        tileToMove = i;\n        break;\n      }\n    }\n    this.moveTile(tileToMove);\n  }\n  undo() {\n    if (this.stack.length === 0) return false;\n    this.board = this.stack.pop();\n    this.moves -= 1;\n  }\n  getState() {\n    const self = this;\n    return {\n      board: self.board,\n      moves: self.moves,\n      solved: self.isSolved(),\n      seconds: self.seconds\n    };\n  }\n}\n_Tag = Tag;\nTag.instance = null;\nTag.solvedBoard = _Tag.getNewBoard();","map":{"version":3,"names":["NUM_ROWS","NUM_COLS","NUM_TILES","EMPTY_INDEX","SHUFFLE_MOVES_RANGE","MOVE_DIRECTIONS","rand","min","max","Math","floor","random","Tag","getInstance","instance","getNewBoard","console","log","Array","fill","map","a","i","constructor","startNewGame","shuffle","shuffling","shuffleMoves","moveInDirection","moves","board","stack","seconds","canMoveTile","index","tilePos","emptyPos","abs","moveTile","isSolved","emptyPosition","tilePosition","boardAfterMove","push","solvedBoard","dir","epos","posToMove","tileToMove","undo","length","pop","getState","self","solved","_Tag"],"sources":["D:/WebProjects/react_projects/tag-game/src/components/Tag.js"],"sourcesContent":["const NUM_ROWS = 4;\r\nconst NUM_COLS = 4;\r\nconst NUM_TILES = NUM_ROWS * NUM_COLS;\r\nconst EMPTY_INDEX = NUM_TILES - 1;\r\nconst SHUFFLE_MOVES_RANGE = [60, 80];\r\nconst MOVE_DIRECTIONS = ['up', 'down', 'left', 'right'];\r\n\r\nfunction rand (min, max) {\r\n  return min + Math.floor(Math.random() * (max - min + 1));\r\n}\r\n\r\n\r\nexport default class Tag {\r\n  static instance = null;\r\n  static solvedBoard = Tag.getNewBoard();\r\n\r\n  static getInstance () {\r\n    if (!Tag.instance) Tag.instance = new Tag();\r\n    return Tag.instance;\r\n  }\r\n\r\n  static getNewBoard(){\r\n    console.log('get new board')\r\n    return Array(NUM_TILES).fill(0).map((a,i) => [\r\n      Math.floor(i/NUM_ROWS),\r\n      i % NUM_COLS\r\n    ]);\r\n  }\r\n\r\n  constructor(){\r\n    this.startNewGame();\r\n  }\r\n\r\n  shuffle(){\r\n    this.shuffling = true;\r\n    let shuffleMoves = rand(...SHUFFLE_MOVES_RANGE);\r\n    console.log('shuffle -- '+shuffleMoves);\r\n    while (shuffleMoves --> 0) \r\n      this.moveInDirection (MOVE_DIRECTIONS[rand(0,3)]);\r\n    this.shuffling = false;\r\n  }\r\n\r\n  startNewGame()\r\n  {\r\n    this.moves = 0;\r\n    this.board = Tag.getNewBoard();\r\n    this.stack = [];\r\n    this.seconds = 0;\r\n    this.shuffle();\r\n    console.log(\"start new Game\")\r\n  }\r\n\r\n\r\n  canMoveTile (index) {\r\n    console.log('can move tile')\r\n    if (index < 0 || index >= NUM_TILES) return false;\r\n\r\n    const tilePos = this.board[index];\r\n    const emptyPos = this.board[EMPTY_INDEX];\r\n\r\n    if (tilePos[0] === emptyPos[0])\r\n      return Math.abs(tilePos[1] - emptyPos[1]) === 1;\r\n\r\n    else if (tilePos[1] === emptyPos[1])\r\n      return Math.abs(tilePos[0] - emptyPos[0]) === 1;\r\n\r\n    else return false;\r\n  }\r\n\r\n  moveTile (index) {\r\n    console.log('Move title')\r\n    if (!this.shuffling && this.isSolved()) return false;\r\n\r\n    if (!this.canMoveTile(index)) return false;\r\n\r\n    const emptyPosition = [...this.board[EMPTY_INDEX]];\r\n    const tilePosition = [...this.board[index]];\r\n    let boardAfterMove = [...this.board];    \r\n    boardAfterMove[EMPTY_INDEX] = tilePosition;\r\n    boardAfterMove[index] = emptyPosition;\r\n\r\n    if (!this.shuffling) this.stack.push(this.board);\r\n    this.board = boardAfterMove;\r\n    if (!this.shuffling) this.moves += 1;\r\n\r\n    return true;\r\n  }\r\n\r\n  isSolved () {\r\n    for (let i=0; i<NUM_TILES; i++) {\r\n      if (this.board[i][0] !== Tag.solvedBoard[i][0] \r\n          || this.board[i][1] !== Tag.solvedBoard[i][1]) \r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  moveInDirection (dir) {\r\n    const epos = this.board[EMPTY_INDEX];\r\n    console.log(dir +' -- Move direction');\r\n    const posToMove = \r\n      dir === 'up' ? [epos[0]+1, epos[1]]\r\n      : dir === 'down' ? [epos[0]-1, epos[1]]\r\n      : dir === 'left' ? [epos[0], epos[1]+1]\r\n      : dir === 'right' ? [epos[0], epos[1]-1]\r\n      : epos;\r\n\r\n    let tileToMove = EMPTY_INDEX;\r\n    for (let i=0; i < NUM_TILES; i++) {\r\n      if (this.board[i][0] === posToMove[0] && this.board[i][1] === posToMove[1]) {\r\n        tileToMove = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.moveTile(tileToMove);\r\n  }\r\n\r\n  undo () {\r\n    if (this.stack.length === 0) return false;\r\n    this.board = this.stack.pop();\r\n    this.moves -= 1;\r\n  }\r\n\r\n  getState () {  \r\n    const self = this;\r\n    return {\r\n      board: self.board,\r\n      moves: self.moves,\r\n      solved: self.isSolved(),\r\n      seconds: self.seconds\r\n    };\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}